---
layout: post
title:  "Execution Contexts, Closures And Lexical Evironoments"
date:   2020-04-09 09:39:37 +0300
description: "
Lately, there’s been a push from the React team to move from class components to functional components and hooks. This makes sense because even though JS supports classes, it’s primarily a functional language, and the class syntax is merely syntactic sugar. The motivation for writing this article came from various frustrations regarding this new way of doing this. Even though classes in C# or Java look superficially similar to those in JS, they are fundamentally different under the hood.
"
icon: "closures/js.png"
categories:
---
Lately, there’s been a push from the React team to move from class components to functional components and hooks, which makes sense because even though JS supports classes, it’s primarily a functional language, and the class syntax is merely syntactic sugar. The motivation for writing this article came from various frustrations regarding this new way of doing this. Even though classes in C# or Java look superficially similar to those in JS, they are fundamentally different under the hood.

Since C# is an OOP language, classes are world-class citizens. That’s not the case, however, with JavaScript, which is more functional. With JS, functions can exist outside classes and are the first-class citizens, and before ES6, we didn’t even have classes. A typical JS function would look like this:

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
function logFullName(firstName, lastName) {  
  console.log(`${firstName} ${lastName}`)
}

logFullName('John', 'Doe') // outputs 'John Doe' to the console
</code></pre>
</div>

Let's now spice things up a little bit.

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
const logFullName1 = function(firstName, lastName) {  
  console.log(`${firstName} ${lastName}`)
}

const logFullName2 = function(firstName, lastName) {  
  console.log(`${firstName} ${lastName}`)
}

const logFullName3 = logFullName1

console.log(logFullName1 === logFullName2) // false
console.log(logFullName1 === logFullName3) // true
</code></pre>
</div>

We can clearly see functions are treated like objects and we can even create them dynamically at runtime like this (which can make for nice meta-programming). Since JS is a dynamic language, we can even write:

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
const f = new Function(`console.log('Hello there')`)
f() // Hello there
</code></pre>
</div>

JS clearly stands in contrast with statically linked languages like C, where the function compiles to a set of machine language instructions that live somewhere in memory.

Another aspect of JS is that we can write functions inside other functions, which has some interesting implications -- but we'll show a simple example first.

So far, nothing special -- a function sees a variable from its own scope scope or the outer scope.

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
function multiplyBy(factor) {
  const _factor = factor

  return function multiply(val) {    
    console.log(_factor * x)
  }
}

const multiplyBy2 = multiplyBy(2) // this is a function that multiplies a val by 2
const multiplyBy3 = multiplyBy(2) // this is a function that multiples a val by 3

console.log(multiplyBy2(5)) // outputs 10
console.log(multiplyBy3(5)) // outputs 15
</code></pre>
</div>

We have just created a higher order function, by the way, which is a staple of functional programing. The line...

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
const _factor = factor
</code></pre>
</div>

...isn't needed because we could have just used `factor`, but was added to ilustrate a point.

The idea behind closures is the lexical environment works similar to instance state in OOP. To illustrate this:

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
function Employee(firstName, lastName, position) {
  let _firstName = firstName
  let _lastName = lastName

  return {    
    getFistName: () => {
      return `${firstName} ${lastName}`
    }

    setFirstName: (firstName) => {
      _firstName = firstName
    }

    setLastName: (lastName) => {
      _lastName = lastName
    }
  }  
}

const employee1 = Employee('John', 'Doe')
const employee2 = Employee('Jane', 'Doe')

console.log(employee1.getFullName())
console.log(employee2.getFullName())
</code></pre>
</div>

Even though the employee function has finished executing, since the `getFirstName`, `setFirstName` and `setLastTIme` functions still have access to the `_firstName` and `_lastName` fields. But because we called it twice, we have two copies of those values just like we would have different values for different instances of the same class. The fields 

Since React functional components are closures, and you're just starting out with hooks, understanding how closures work under the hood can prevent a lot of problems down the road.
