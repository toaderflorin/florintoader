---
layout: post
title:  "Thoughts On Hooks"
date:   2020-04-09 09:39:37 +0300
description: "
Of course, when the syntax became available, the React team quickly switched to it and started supporting it. But because React is highly compositional and some components are purely presentational (we have child components that might show just an item in a list), they came up with the concept of functional components."
icon: "ddd/ddd-icon.jpg"
categories:
---
Of course, when the syntax became available, the React team quickly switched to it and started supporting it. But because React is highly compositional and some components are purely presentational (we have child components that might show just an item in a list), they came up with the concept of functional components. 

![diagram2](/images/hooks/hooks.jpg){:class="img-responsive"}

This makes perfect sense. Not only is the syntax terser, but it also ensures that the only responsibility of these components is to present data - in pure functional fashion, no side effects are allowed, which is excellent. And of course, quite a few people did love the simplicity of using functional components because the simplified syntax is quite appealing. Not to mention there is also a cool factor in writing functional code, which made a lot of developers want to embrace it (there's no coincidence Elm is so hot right now).

The question then becomes: how does one keep the functional syntax and, at the same time, allows for the use of state in a component (for example)? The answer is, of course, hooks.

There's a `useState` hook, for example. There's also a `useEffect`, and we'll look at both in a moment. Let's consider a simple application that fetches some data from an API and then does something.

<div class="margin-bottom">
<pre><code class="language-js line-numbers">
function App() {
  const [state, setState] = useState([])

  async function makeApiCall() {

  }
  
  useEffect(() => {

  })

  return (
    &#x3C;div&#x3E;
      ... code to render
    &#x3C;/div&#x3E;
  )
}
</code></pre>
</div>

It's worth pointing out that the way `setState` works with hooks is different that the way `setState` works with class components.

1. With class components, it merges the new state into the old state.
2. With functional components, it simply replaces the state object. 

You might have noticed something: when the response comes back from the server, the state's value is the same as it was when the component was called. For simple state, like populating a collection of items, this wouldn't be a problem. But what if you have a simple application, you don't want to use something like Redux, and you simple 
